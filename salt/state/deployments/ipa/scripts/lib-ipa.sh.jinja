#!/bin/bash

registered_hosts_file="/etc/ss-hosts-{{deployment_name}}"
ipa_realm="{{config.realm}}"
default_reverse_zone="{{config.reverse_zone}}"
default_regular_zone="{{config.domain}}"
default_site="{{config.site}}"
ip_octet='[0-9]{1,3}'

# NOTE: except for fqdn_regex where it is unavoidable, these regex 
# for IP and MAC and hostname deliberately do not use capturing groups or include anchors (^ and $)
# because they are intended to be include-able within other regular expressions
# The _single versions do include anchors
# The _embedded versions will match inside a string (at start or end, or with spaces on either side)

ip_regex="${ip_octet}[.]${ip_octet}[.]${ip_octet}[.]${ip_octet}"
ip_regex_single="^${ip_regex}\$"

mac_octet='[aAbBcCdDeEfF0-9]{2}'
mac_regex="${mac_octet}:${mac_octet}:${mac_octet}:${mac_octet}:${mac_octet}:${mac_octet}"
mac_regex_single="^${mac_regex}\$"
# No embedded version for mac address, as it is a fixed length it's not necessary to distinguish where it is

host_octet1="[a-zA-Z0-9]"
host_octet="[-a-zA-Z0-9_]"
host_part_regex="${host_octet1}${host_octet}*"
host_part_single="^${host_part_regex}\$"
host_part_embedded="^"

fqdn_regex="${host_part_regex}([.]${host_part_regex})+"
fqdn_regex_single="^${fqdn_regex})\$"
fqdn_regex_at_start="^${fqdn_regex}[[:space:]]"
fqdn_regex_at_end="[[:space:]]${fqdn_regex}\$"
fqdn_regex_in_middle="[[:space:]]${fqdn_regex}[[:space:]]"
fqdn_regex_embedded="${fqdn_regex_single}|${fqdn_regex_at_start}|${fqdn_regex_in_middle}|${fqdn_regex_at_end}"

reverse_regex_xyz="${ip_octet}[.]${ip_octet}[.]${ip_octet}[.]in-addr[.]arpa"
reverse_regex_yz="${ip_octet}[.]${ip_octet}[.]in-addr[.]arpa"
reverse_regex_z="${ip_octet}[.]in-addr[.]arpa"
reverse_regex="${reverse_regex_xyz}|${reverse_regex_yz}|${reverse_regex_z}"
reverse_regex_single="^(${reverse_regex})$"
# No _embedded version for reverse_regex - it's not needed yet and would be very long 

# Set LC_COLLATE to make sure [a-f] is just "abcdef" not  "aAbBcCdDeEfF" or "abcdefghijklmnopqrstuvwxyzABCDEF" depending on case sensitivity
export LC_COLLATE=C

# Match an ss-hosts line into 4 matching groups - 1=ip, 2= fqdn, 3=domain, 4=aliases 5=entry-type 6=mac
ss_host_regex="^(${ip_regex})[[:space:]]+(${fqdn_regex})[[:space:]]*(.*)#[[:space:]]*(client|dns)[[:space:]]+(${mac_regex})([[:space:]]|\$)"

function msg()
{
    echo "${*}" 1>&2
}

function logmsg()
{
    echo "${*}" 1>&2
    /usr/bin/logger -p auth.notice "${0##*/}" "[${UID}:$$]" "${*}"
}

function err()
{
    msg "ERROR:" "${@}"
}

function die()
{
    err "${@}"
    exit 1
}

function run()
{
    msg "run ${*}"
    "${@}"
}

function salt_lookup_managed_host()
{
    local name="${1}"
    msg "Looking up managed host '${name}' this can take a little while..."
    local short_hostname="${name%%.*}"
    salt-call pillar.get "managed-hosts:{{deployment_name}}:${short_hostname}" --out key | grep -v 'Local Keys' | sed 's/:[[:space:]]*/=/'
}

function salt_lookup()
{
    local short_hostname="${1}"
    shift
    local lookup_what=( "${@}" )
    local -a result=()
    local -a ret=()
    local what=""
    result=( $(salt_lookup_managed_host "${short_hostname}") )

    for what in "${lookup_what[@]}"
    do
        local found=""
        local result_item
        for result_item in "${result[@]}"
        do 
            local key="${result_item%%=*}"
            if [[ "${key}" == "${what}" ]]
            then 
                found="${result_item#*=}"
                break
            fi
        done
        if [[ -z "${found}" ]]
        then
            msg "No salt '${what}' information found for host '${short_hostname}'"
            found="-"
        fi
        ret+=("${found}")
    done 

    echo "${ret[@]}"
}

function lookup_host_info_registered_hostfile()
{
    local fqdn="${1}"

    local line this_ip this_fqdn remainder aliases found_host_ip found_mac  
    local -a hostdata_lines=()

    readarray -t hostdata_lines < "${registered_hosts_file}"

    for line in "${hostdata_lines[@]}"
    do
        #echo line is "'$line'"
        read this_ip this_fqdn remainder <<< "${line}"
        if [[ "${this_fqdn}" == "${fqdn}" ]]
        then 
            aliases="${remainder%#*}"
            found_host_ip="${this_ip}"
            found_mac=$( awk '{print $1}' <<< "${remainder#*#}")
            break
        fi
    done

    echo "${found_host_ip:--}" "${found_mac:--}"
}

function lookup_host_info()
{
    local fqdn="${1}"
    local short_hostname="${fqdn%%.*}"
    local -a salt_result=( $(salt_lookup "${short_hostname}" "ip" "mac") )
    local ip="${salt_result[0]}"
    local mac="${salt_result[1]}"
    if [[ "${ip}" == "-" || "${mac}" == "-" ]]
    then 
        local -a file_result=( $(lookup_host_info_registered_hostfile "${fqdn}") )
        [[ "${ip}" == "-" ]] && ip="${file_result[0]}"
        [[ "${mac}" == "-" ]] && mac="${file_result[1]}"
    fi
    echo "${ip}" "${mac}"
}

function reregister_check()
{
    local fqdn="${1}"
    local reregister="${2}"
    if ipa host-find "${fqdn%.}"
    then
        if [[ -z "${reregister}" || "${reregister}" == "ask" ]]
        then 
            local confirmation
            logmsg "The host ${fqdn} is already enrolled."
            msg "Do you wish to delete it and re-add?"
            read -p "[n/Y]: " confirmation
            if [[ "${confirmation,,}" != "y" ]]
            then
                logmsg "User cancelled add of host ${fqdn%.}"
                return 1
            else
                logmsg "User confirmed removal of ${fqdn%.} before re-add."
                reregister=1
            fi
        fi
        if [[ "${reregister}" == "1" ]]
        then 
            host-rm "${fqdn%.}"
            return $?
        else 
            return 0
        fi
    else
        return 0
    fi
}

function reverse_zone_for_ip()
{
    echo $(tr '.' '\n' <<< "${1}" | head -n3 | tac | tr '\n' '.')in-addr.arpa
}

function delete_dnsrecords()
{
    local fqdn="${1}"
    local ip="${2}"
    local d="${fqdn#*.}"
    local n="${fqdn%%.*}"
    local r=$(reverse_zone_for_ip "${ip}")
    local final_octet="${ip##*.}"
    # At this point, fqdn should include a . at the end 
    run ipa dnsrecord-del "${d}" "${n}"           --a-rec   "${ip}"
    run ipa dnsrecord-del "${r}" "${final_octet}" --ptr-rec "${fqdn}"
}

function add_dnsrecords()
{
    local fqdn="${1}"
    local ip="${2}"
    local d="${fqdn#*.}"
    local n="${fqdn%%.*}"
    local r=$(reverse_zone_for_ip "${ip}")
    local final_octet="${ip##*.}"
    
    if ! ipa dnsrecord-find "${d}" "${n}" --raw | grep -q "arecord: ${ip}"
    then
        run ipa dnsrecord-add "${d}" "${n}"           --a-rec   "${ip}"
    else 
        echo "DNS record ${d} ${n} A ${ip} already exists" 
    fi

    if ! ipa dnsrecord-find "${r}" "${final_octet}" --raw | grep -q "ptrrecord: ${fqdn}"
    then 
        run ipa dnsrecord-add "${r}" "${final_octet}" --ptr-rec "${fqdn}"
    else
        echo "DNS record ${r} ${final_octet} PTR ${fqdn} already exists"
    fi
}

function host_add()
{
    local kind="${1}"
    local reregister="${2}"
    local fqdn="${3}"
    local host_ip="${4}"
    local mac="${5}"
    local site="${6:-${default_site}}"
    local otp="${7:-otp}"

    if ! require_ticket admin
    then 
        return 1
    fi

    if [[ "${kind}" == "host" ]]
    then 
        if ! reregister_check "${fqdn}" "${reregister}"
        then
            return 1
        fi
    fi 

    if [[ "${kind}" == "host" ]]
    then 
        delete_dnsrecords "${fqdn}" "${host_ip}" 2> /dev/null
        logmsg "Registering host ${fqdn%.}"
        run ipa host-add "${fqdn%.}" --ip "${host_ip}" --mac "${mac}" --password="${otp}" --location="${site}"
    elif [[ "${kind}" == "dns" ]]
    then
        add_dnsrecords "${fqdn}" "${host_ip}"
    fi
}


function host_rm()
{
    local fqdn="${1}"
    local deregister="${2}"

    if ! require_ticket admin
    then 
        return 1
    fi
    
    if (( deregister ))
    then 
        msg "Searching for ${fqdn%.}"
        if ipa host-find "${fqdn%.}" 2> /dev/null > /dev/null
        then 
            run ipa host-del "${fqdn%.}"
        else 
            msg "Host ${fqdn} was not registered"
        fi 
    fi 

    delete_dnsrecords "${fqdn}" "${host_ip}" 2> /dev/null
    echo $?
}

function require_ticket()
{
    local ticket_name="${1}@${ipa_realm}"
    if klist -l | grep "${ticket_name}"
    then
        return 0
    else 
        kinit "${ticket_name}"
    fi
}

function is_bind_user()
{
    local user_name="${1}"
    if groups "${user_name}" | egrep '[[:space:]]bind-users([[:space:]]|$)'
    then 
        return 0
    else
        return 1
    fi 
}

function save_bind_user_pw()
{
    local user_name="${1:-bind-user}"
    local pw="${2}"
    mkdir -p /root/.bind-users
    cat > "/root/.bind-users/${user_name}.txt" <<< "${pw}" 
    chmod go-rwx /root/.bind-users/*
    chmod o-rwx /root/.bind-users /root
    chgrp root /root 
}

function send_password_email()
{
    local user_name="${1}"
    local new_pw="${2}"
    local emailaddr="${3}"
    if ! [[ "${emailaddr}" =~ @ ]]
    then 
        err "Invalid email '${emailaddr}'"
        return 1
    fi
    # TODO - support half/half passwords
    # TODO - support email template from pillar
    local data="
        From: root@$(hostname -f)
        To:   ${emailaddr}
        Subject: Password reset 

        Your password has been reset to ${new_pw}.

    "
    data=$(sed 's/^[[:space:]]*//' <<< "${data}")
    if mail -s "Password reset" "${emailaddr}" <<< "${data}"
    then 
        msg "Sent."
        return 0
    else 
        msg "Not sent (failed)."
        return 1
    fi 
}

function reset_user_password()
{
    local user_name="${1}"
    local send_email="${2:-0}"

    if ! require_ticket admin
    then 
        return 1
    fi

    local new_password=$(mktemp -u XXXXXXXXXX)
    if [[ -z "${new_password}" ]]
    then 
        err "Failed to generate a random password"
        return 1
    fi

    local password_input="${new_password}"$'\n'"${new_password}"$'\n'
    if ! ipa passwd "${user_name}" <<< "${password_input}"
    then 
        err "Failed setting password for user '${user_name}'"
        return 1
    fi
    if is_bind_user "${user_name}"
    then 
        save_bind_user_pw "${user_name}" "${new_password}"
    fi  

    local email_address=$(ipa user-show "${user_name}" --raw | grep mail: | cut -d ':' -f2- | tr -d ' ')
    local sent=0

    if (( send_email )) 
    then
        if [[ -n "${email_address}" ]]
        then 
            if send_password_email "${user_name}" "${new_password}" "${email_address}"
            then 
                sent=1
            else 
                err "Sending failed."
            fi
        else 
            err "The user has no email address set."
        fi
    fi 

    if ! (( sent ))
    then
        msg "The user password was set to ${new_password}"
    fi
}
